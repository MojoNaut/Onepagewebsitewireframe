<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rubik Cube â€” No White Interior</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #F5F1E8;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: 'Inter', system-ui, sans-serif;
    color: #1a1a1a;
  }
  .container { display: flex; flex-direction: column; align-items: center; gap: 28px; }
  svg { width: 520px; height: 520px; }
  .controls { display: flex; flex-direction: column; gap: 12px; align-items: center; width: 400px; }
  .slider-row { display: flex; align-items: center; gap: 12px; width: 100%; }
  .slider-row label { font-size: 13px; min-width: 110px; letter-spacing: 0.05em; text-transform: uppercase; color: #666; }
  .slider-row input[type="range"] { flex: 1; accent-color: #C4B5FD; }
  .slider-row .val { font-size: 13px; min-width: 52px; text-align: right; font-variant-numeric: tabular-nums; }
  .btn-row { display: flex; gap: 8px; margin-top: 8px; }
  button { padding: 8px 20px; border: 1px solid #D4CFC4; background: transparent; border-radius: 999px; font-size: 13px; cursor: pointer; letter-spacing: 0.03em; transition: all 0.2s; }
  button:hover { background: #1a1a1a; color: #F5F1E8; border-color: #1a1a1a; }
  button.active { background: #1a1a1a; color: #F5F1E8; border-color: #1a1a1a; }
  h2 { font-size: 14px; letter-spacing: 0.15em; text-transform: uppercase; color: #666; }
  .move-display { font-size: 13px; color: #999; letter-spacing: 0.05em; font-variant-numeric: tabular-nums; min-height: 20px; text-align: center; }
  .info { font-size: 11px; color: #999; text-align: center; line-height: 1.6; }
</style>
</head>
<body>
<div class="container">
  <h2>Rubik Cube â€” Full Interior</h2>
  <svg id="cubeSvg" viewBox="0 0 200 200"></svg>
  <div class="move-display" id="moveDisplay">Top: 0Â° Â· Right: 0Â° Â· Left: 0Â°</div>

  <div class="controls">
    <div class="slider-row">
      <label>Progress</label>
      <input type="range" id="progressSlider" min="0" max="1" value="0" step="0.002">
      <span class="val" id="progressVal">0%</span>
    </div>
    <div class="slider-row">
      <label>Stroke</label>
      <input type="range" id="strokeSlider" min="0" max="0.8" value="0.3" step="0.05">
      <span class="val" id="strokeVal">0.30</span>
    </div>
    <div class="slider-row">
      <label>Gap</label>
      <input type="range" id="gapSlider" min="0" max="0.3" value="0.08" step="0.01">
      <span class="val" id="gapVal">0.08</span>
    </div>
    <div class="slider-row">
      <label>Lighting</label>
      <input type="range" id="lightSlider" min="0" max="0.5" value="0.22" step="0.01">
      <span class="val" id="lightVal">0.22</span>
    </div>
    <div class="btn-row">
      <button id="btnAnimate">Animate</button>
      <button id="btnReset">Reset</button>
      <button id="btnLabels">Labels</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// PALETTE â€” outer faces + interior color
// ============================================================
const FACE_COLORS = {
  '+z': '#EDE8DD', '-z': '#C4BAA8',
  '+x': '#C4B5FD', '-x': '#D5C8B8',
  '+y': '#B8C4D0', '-y': '#D4CFC4',
};

// Interior faces â€” warm dark neutral (like looking inside the cube mechanism)
const INTERIOR_COLOR = '#D0C9BC';

// ============================================================
// MATH
// ============================================================
const LIGHT_DIR = (() => {
  const v = [0.4, -0.3, 0.8];
  const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  return [v[0]/len, v[1]/len, v[2]/len];
})();

function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
function hexToRgb(h) { return [parseInt(h.slice(1,3),16), parseInt(h.slice(3,5),16), parseInt(h.slice(5,7),16)]; }
function rgbToHex(r, g, b) {
  const c = v => Math.max(0, Math.min(255, Math.round(v)));
  return '#' + [c(r), c(g), c(b)].map(v => v.toString(16).padStart(2,'0')).join('');
}
function adjustBrightness(hex, f) {
  const [r,g,b] = hexToRgb(hex);
  if (f > 0) return rgbToHex(r+(255-r)*f, g+(255-g)*f, b+(255-b)*f);
  const m = 1+f; return rgbToHex(r*m, g*m, b*m);
}

function rotZ(v, a) { const c=Math.cos(a),s=Math.sin(a); return [v[0]*c-v[1]*s, v[0]*s+v[1]*c, v[2]]; }
function rotX(v, a) { const c=Math.cos(a),s=Math.sin(a); return [v[0], v[1]*c-v[2]*s, v[1]*s+v[2]*c]; }
function rotY(v, a) { const c=Math.cos(a),s=Math.sin(a); return [v[0]*c+v[2]*s, v[1], -v[0]*s+v[2]*c]; }

// ============================================================
// BUILD CUBIES â€” ALL 6 FACES per cubie
// ============================================================
function buildCubies(gap) {
  const cubies = [];
  const size = 2, half = gap / 2;

  for (let ix = 0; ix < 3; ix++) {
    for (let iy = 0; iy < 3; iy++) {
      for (let iz = 0; iz < 3; iz++) {
        const cx = (ix-1)*size, cy = (iy-1)*size, cz = (iz-1)*size;
        const s = size/2 - half;
        const faces = [];

        // Determine which faces are "outer" (on the cube shell)
        const isOuterPZ = iz === 2;  // +z top
        const isOuterNZ = iz === 0;  // -z bottom
        const isOuterPX = ix === 2;  // +x right
        const isOuterNX = ix === 0;  // -x left
        const isOuterPY = iy === 2;  // +y front
        const isOuterNY = iy === 0;  // -y back

        // +Z face (top)
        faces.push({
          verts: [[cx-s,cy-s,cz+s],[cx+s,cy-s,cz+s],[cx+s,cy+s,cz+s],[cx-s,cy+s,cz+s]],
          normal: [0,0,1],
          faceId: isOuterPZ ? '+z' : 'interior',
        });
        // -Z face (bottom)
        faces.push({
          verts: [[cx-s,cy+s,cz-s],[cx+s,cy+s,cz-s],[cx+s,cy-s,cz-s],[cx-s,cy-s,cz-s]],
          normal: [0,0,-1],
          faceId: isOuterNZ ? '-z' : 'interior',
        });
        // +X face (right)
        faces.push({
          verts: [[cx+s,cy-s,cz-s],[cx+s,cy+s,cz-s],[cx+s,cy+s,cz+s],[cx+s,cy-s,cz+s]],
          normal: [1,0,0],
          faceId: isOuterPX ? '+x' : 'interior',
        });
        // -X face (left)
        faces.push({
          verts: [[cx-s,cy+s,cz-s],[cx-s,cy-s,cz-s],[cx-s,cy-s,cz+s],[cx-s,cy+s,cz+s]],
          normal: [-1,0,0],
          faceId: isOuterNX ? '-x' : 'interior',
        });
        // +Y face (front)
        faces.push({
          verts: [[cx+s,cy+s,cz-s],[cx-s,cy+s,cz-s],[cx-s,cy+s,cz+s],[cx+s,cy+s,cz+s]],
          normal: [0,1,0],
          faceId: isOuterPY ? '+y' : 'interior',
        });
        // -Y face (back)
        faces.push({
          verts: [[cx-s,cy-s,cz-s],[cx+s,cy-s,cz-s],[cx+s,cy-s,cz+s],[cx-s,cy-s,cz+s]],
          normal: [0,-1,0],
          faceId: isOuterNY ? '-y' : 'interior',
        });

        cubies.push({ ix, iy, iz, faces });
      }
    }
  }
  return cubies;
}

// ============================================================
// LAYER MEMBERSHIP (same logic as before)
// ============================================================
const TOP_FULL = Math.PI / 2;
const RIGHT_FULL = -Math.PI / 2;

function getCubieCenter(c) { return [(c.ix-1)*2, (c.iy-1)*2, (c.iz-1)*2]; }
function isTopLayer(c) { return c.iz === 2; }

function isEffectiveRight(c) {
  let center = getCubieCenter(c);
  if (isTopLayer(c)) center = rotZ(center, TOP_FULL);
  return Math.abs(center[0] - 2) < 0.5;
}

function isEffectiveLeft(c) {
  let center = getCubieCenter(c);
  if (isTopLayer(c)) center = rotZ(center, TOP_FULL);
  if (isEffectiveRight(c)) center = rotX(center, RIGHT_FULL);
  return Math.abs(center[1] - 2) < 0.5;
}

function computeMembership(cubies) {
  return cubies.map(c => ({
    cubie: c,
    isTop: isTopLayer(c),
    isRight: isEffectiveRight(c),
    isLeft: isEffectiveLeft(c),
  }));
}

// ============================================================
// PROJECTION & TIMING
// ============================================================
const SCALE=13, CX=100, CY=100, BASE_ANGLE=Math.PI/4, PAUSE=0.08;

function projectPoint(x,y,z) {
  const c=Math.cos(BASE_ANGLE), s=Math.sin(BASE_ANGLE);
  return [(x*c-y*s)*SCALE+CX, ((x*s+y*c)-z*Math.SQRT2)*SCALE/Math.sqrt(3)+CY];
}
function isVisible2D(pts) {
  const [a,b,c] = pts;
  return (b[0]-a[0])*(c[1]-a[1])-(b[1]-a[1])*(c[0]-a[0]) > 0;
}
function easeInOutCubic(t) { return t<0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2; }
function centroid2D(pts) {
  let sx=0,sy=0; for(const p of pts){sx+=p[0];sy+=p[1];}
  return [sx/pts.length, sy/pts.length];
}

function computeAngles(p) {
  const third = 1/3;
  function frac(start, end) {
    if (p <= start) return 0;
    if (p >= end) return 1;
    const mp = (p - start) / (end - start);
    const ae = 1 - PAUSE;
    return mp <= ae ? easeInOutCubic(mp / ae) : 1;
  }
  const topF = frac(0, third);
  const rightF = frac(third, 2*third);
  const leftF = frac(2*third, 1);
  return {
    topAngle: topF * TOP_FULL,
    rightAngle: rightF * RIGHT_FULL,
    leftAngle: leftF * (Math.PI/2),
    topDeg: Math.round(topF*90),
    rightDeg: Math.round(rightF*90),
    leftDeg: Math.round(leftF*90),
  };
}

// ============================================================
// STATE
// ============================================================
let cubies = buildCubies(0.08);
let membership = computeMembership(cubies);
let strokeWidth = 0.3, lightIntensity = 0.22, progress = 0;
let animating = false, showLabels = false;
const svg = document.getElementById('cubeSvg');
const moveDisplay = document.getElementById('moveDisplay');

// ============================================================
// RENDER
// ============================================================
function render(p) {
  const {topAngle, rightAngle, leftAngle, topDeg, rightDeg, leftDeg} = computeAngles(p);
  const isTopPhase = p > 0 && p < 1/3;
const isRightPhase = p > 1/3 && p < 2/3;
const isLeftPhase = p > 2/3 && p < 1;

  moveDisplay.textContent = `Top: ${topDeg}Â° Â· Right: ${rightDeg}Â° Â· Left: ${leftDeg}Â°`;

const all = [];

  for (const {cubie, isTop, isRight, isLeft} of membership) {
    for (const face of cubie.faces) {
      // Nascondi facce interne quando il cubo Ã¨ chiuso
if (face.faceId === 'interior' && p < 0.001) {
  continue;
}


      let verts = face.verts.map(v => [...v]);
      let normal = [...face.normal];

      if (isTop && topAngle) { verts = verts.map(v => rotZ(v, topAngle)); normal = rotZ(normal, topAngle); }
      if (isRight && rightAngle) { verts = verts.map(v => rotX(v, rightAngle)); normal = rotX(normal, rightAngle); }
      if (isLeft && leftAngle) { verts = verts.map(v => rotY(v, leftAngle)); normal = rotY(normal, leftAngle); }

      const proj = verts.map(v => projectPoint(v[0], v[1], v[2]));
      if (!isVisible2D(proj)) continue;

    const cs = Math.cos(BASE_ANGLE),
      ss = Math.sin(BASE_ANGLE);
// profonditÃ  basata sul centro della faccia (molto piÃ¹ stabile)
const center = verts.reduce(
  (acc, v) => [acc[0] + v[0], acc[1] + v[1], acc[2] + v[2]],
  [0, 0, 0]
).map(v => v / 4);

let depth = (center[0]*ss + center[1]*cs) - center[2]*0.5;
if (face.faceId === 'interior') {
  depth -= 50;
}

// ======================================================
// BOOST INTELLIGENTE PER FASE DI ANIMAZIONE
// ======================================================

if (p > 0 && p < 1) {

  // ðŸ”µ PRIMA FASE (top move)
  if (p < 1/3) {
    if (cubie.iz === 2) {
      depth += 40;
    }
  }

  // ðŸŸ£ SECONDA FASE (right move)
  else if (p < 2/3) {
    if (cubie.ix === 2) {
      depth += 40;
    }
  }
// Patch specifica: +Z sopra +X durante Right phase
if (p > 1/3 && p < 2/3) {
  if (cubie.ix === 2 && face.faceId === '+z') {
    depth += 6; // leggermente sopra FACE_PRIORITY di +X
  }
}

// PATCH â€“ 002--X deve stare davanti durante RIGHT
if (p > 1/3 && p < 2/3) {

  const is002minusX =
    cubie.ix === 0 &&
    cubie.iy === 0 &&
    cubie.iz === 2 &&
    face.faceId === '-x';

  if (is002minusX) {
    depth += 48; // supera il +40 del layer right
  }
// PATCH â€“ 002-+Z deve stare davanti durante RIGHT
const is002plusZ =
  cubie.ix === 0 &&
  cubie.iy === 0 &&
  cubie.iz === 2 &&
  face.faceId === '+z';

if (is002plusZ) {
  depth += 52; // supera +40 +6 del layer right
}

}
  // ðŸŸ£ terza FASE (left move)
else {

  const { ix, iy, iz } = cubie;

  const isPriorityCubie =
    (ix === 2 && iz === 2) ||
    (ix === 2 && iy === 2);

  if (isPriorityCubie) {
    depth += 40;
  }

  const isLeftConflict =
    (ix === 0 && iy === 0 && iz === 2) ||
    (ix === 1 && iy === 0 && iz === 2);

  const isPurpleColumn = ix === 2 && face.faceId === '+x';

  if (isLeftConflict) {
    depth += 12;
  }

  if (isPurpleColumn) {
    depth -= 6;
  }

  // PATCH â€“ 002--X deve stare davanti durante LEFT
  const is002minusX =
    ix === 0 &&
    iy === 0 &&
    iz === 2 &&
    face.faceId === '-x';

  if (is002minusX) {
    depth += 48;
  }

}

}




// PrioritÃ  visiva controllata
const FACE_PRIORITY = {
  '+x': 5,  // viola (piÃ¹ davanti)
  '+y': 4,  // blu
  '+z': 3,  // sopra
  '-x': 2,
  '-y': 1,
  '-z': 0
};

depth += FACE_PRIORITY[face.faceId] || 0;


      const rotN = rotZ(normal, BASE_ANGLE);
      const layers = (isTop?1:0) + (isRight?1:0) + (isLeft?1:0);

const faceUID = `${cubie.ix}${cubie.iy}${cubie.iz}-${face.faceId}`;

const faceObj = {
  points: proj,
  rotatedNormal: rotN,
  depth,
  faceId: face.faceId,
  cubie: cubie,
  faceUID: faceUID,
  isTop,
  isRight,
  isLeft,
  layers,
};



all.push(faceObj);



    }
  }
function sortFn(a, b) {
  if (Math.abs(a.depth - b.depth) < 0.0001) {
    return a.faceUID.localeCompare(b.faceUID);
  }
  return a.depth - b.depth;
}

all.sort(sortFn);
  let html = '';
  for (const f of all) {
    // Use interior color for non-outer faces
// Use interior color for non-outer faces
const isInterior = f.faceId === 'interior';

let color;

if (isInterior) {
  color = INTERIOR_COLOR;
} else {
  const { ix, iy, iz } = f.cubie;

  if (f.faceId === '+x') color = '#A78BFA';      // destra
  else if (f.faceId === '-x') color = '#E5E7EB'; // sinistra
  else if (f.faceId === '+y') color = '#93C5FD'; // fronte
  else if (f.faceId === '-y') color = '#FDE68A'; // retro
  else if (f.faceId === '+z') color = '#FFFFFF'; // sopra
  else if (f.faceId === '-z') color = '#FCA5A5'; // sotto
}



    // Interior faces get slightly thinner/lighter stroke
const sw = strokeWidth;
const so = '0.18';


    const pts = f.points.map(p => `${p[0].toFixed(2)},${p[1].toFixed(2)}`).join(' ');
    html += `<polygon points="${pts}" fill="${color}" stroke="rgba(26,26,26,${so})" stroke-width="${sw}" stroke-linejoin="round"/>`;

const [cx, cy] = centroid2D(f.points);

html += `
  <text 
    x="${cx.toFixed(1)}" 
    y="${cy.toFixed(1)}" 
    text-anchor="middle" 
    dominant-baseline="central" 
    font-size="3" 
    font-family="Inter,system-ui,sans-serif" 
    font-weight="700" 
    fill="#111">
    ${f.faceUID}
  </text>
`;

  }
  svg.innerHTML = html;
}

// ============================================================
// ANIMATION
// ============================================================
let animStart = 0;
const ANIM_DURATION = 3600;

function animLoop(now) {
  if (!animating) return;
  if (!animStart) animStart = now;
  progress = Math.min((now - animStart) / ANIM_DURATION, 1);
  document.getElementById('progressSlider').value = progress;
  document.getElementById('progressVal').textContent = Math.round(progress * 100) + '%';
  render(progress);
  if (progress < 1) requestAnimationFrame(animLoop);
  else { animating = false; document.getElementById('btnAnimate').classList.remove('active'); }
}

render(0);

// ============================================================
// CONTROLS
// ============================================================
document.getElementById('progressSlider').addEventListener('input', e => {
  progress = parseFloat(e.target.value);
  document.getElementById('progressVal').textContent = Math.round(progress*100)+'%';
  animating = false; document.getElementById('btnAnimate').classList.remove('active');
  render(progress);
});
document.getElementById('strokeSlider').addEventListener('input', e => {
  strokeWidth = parseFloat(e.target.value);
  document.getElementById('strokeVal').textContent = strokeWidth.toFixed(2);
  render(progress);
});
document.getElementById('gapSlider').addEventListener('input', e => {
  const g = parseFloat(e.target.value);
  document.getElementById('gapVal').textContent = g.toFixed(2);
  cubies = buildCubies(g); membership = computeMembership(cubies); render(progress);
});
document.getElementById('lightSlider').addEventListener('input', e => {
  lightIntensity = parseFloat(e.target.value);
  document.getElementById('lightVal').textContent = lightIntensity.toFixed(2);
  render(progress);
});
document.getElementById('btnAnimate').addEventListener('click', e => {
  if (!animating) {
    progress = 0; animStart = 0; animating = true;
    e.target.classList.add('active');
    requestAnimationFrame(animLoop);
  }
});
document.getElementById('btnReset').addEventListener('click', () => {
  progress = 0; animating = false; animStart = 0;
  document.getElementById('progressSlider').value = 0;
  document.getElementById('progressVal').textContent = '0%';
  document.getElementById('btnAnimate').classList.remove('active');
  render(0);
});
document.getElementById('btnLabels').addEventListener('click', e => {
  showLabels = !showLabels;
  e.target.classList.toggle('active', showLabels);
  render(progress);
});
</script>
</body>
</html>
